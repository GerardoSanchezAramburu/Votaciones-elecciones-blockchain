// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;


// Smart Contract Hospital central CDMX, Realiza las autorizaciones.
contract Hospitacentral_CDMX {

    // Dirección del Hospital Central será publica y administrada por el owner.
    address public Hospitalcentral;
    
    // Constructor del smart contract. 
    constructor () {
        Hospitalcentral = msg.sender;
    }
    
    // Mapping para realizar validación si un centro de salud tiene permisos de ingreso. 
    mapping (address => bool) public Validacion_CentrosSalud;
    
    // Relaciona un centro de salud con la dirección de su smart contract. 
    mapping (address => address) public CentroSalud_Contrato;
    
    // Realiza la función de guarda todos los contratos creados de centros de salud.
    address[] public direcciones_contratos_salud;
    
    // solicitudes que piden acceso
    address[] Solicitudes;
    
    // Eventos.
    event SolicitudAcceso(address);
    event NuevoCentroValidado(address);
    event NuevoContrato(address, address);
    
    // Función que puede realizar solamente el Hospital central_CDMX.
    modifier UnicamenteHospitalcentral() {
        require(msg.sender == Hospitalcentral, "No tienes permisos para realizar esta funcion.");
        _;
    }
    
    // Cualquier centro podrá solicitar acceso al sistema.
    function SolicitarAcceso() public {
        Solicitudes.push(msg.sender);
        emit SolicitudAcceso(msg.sender);
    }
    
    // Solo el Hospital Central puede ver las solicitudes
    function VisualizarSolicitudes() public view UnicamenteHospitalcentral returns (address[] memory) {
        return Solicitudes;
    }
    
    // Solo puede realizar la validación el Hospital Central
    function CentrosSalud(address _centroSalud) public UnicamenteHospitalcentral {
        Validacion_CentrosSalud[_centroSalud] = true;
        emit NuevoCentroValidado(_centroSalud);
    }
    
    // Un centro validado puede desplegar su smart contrat y  autogestionarlo
    function FactoryCentroSalud() public {
        require(Validacion_CentrosSalud[msg.sender] == true, "No tienes permisos para ejecutar esta funcion.");
        address contrato_CentroSalud = address(new CentroSalud(msg.sender));
        direcciones_contratos_salud.push(contrato_CentroSalud);
        CentroSalud_Contrato[msg.sender] = contrato_CentroSalud;
        emit NuevoContrato(contrato_CentroSalud, msg.sender);
    }
    
}

//  smart contract autogentionable.
contract CentroSalud {
    
    // Dirección del centro publica 
    address public DireccionCentroSalud;
    // Dirección del contrato desplegado
    address public DireccionContrato;
    
    // Constructor.
    constructor (address _direccion) {
        DireccionCentroSalud = _direccion;
        DireccionContrato = address(this);
    }
    
    /* Nos pemite realizar un Mapping que relaciona el hash de la persona que se realizo 
     el estudio de gripe con sus resultados*/
    mapping (bytes32 => Resultados) resultadosGripe;
    
    // La estructura de los resultados.
    struct Resultados {
        bool diagnostico;   // true = positivo, false = negativo
        string CodigoIPFS;  // Código IPFS del archivo con más info.
    }
    
    // Cuando se genera un nuevo resultado
    event NuevoResultado(bool, string);
    
    // Solo el hospital dueño puede ejecutar ciertas funciones
    modifier UnicamenteCentroSalud() {
        require(msg.sender == DireccionCentroSalud, "No tienes permisos para ejecutar esta funcion.");
        _;
    }
    
    // Registrar un resultado de prueba de gripe.
    function registrarResultadoGripe(
        string memory _idPersona,
        bool _resultadogripe,
        string memory _codigoIPFS
    ) 
        public 
        UnicamenteCentroSalud 
    {
        // Crear un hash único para identifiacar al paciente.
        bytes32 hash_idPersona = keccak256(abi.encodePacked(_idPersona));
        // Guardar los resultados resultadosGripe
          resultadosGripe[hash_idPersona] = Resultados(_resultadogripe, _codigoIPFS);
        emit NuevoResultado(_resultadogripe, _codigoIPFS);
    }
    
    // Consultar los resultados y general el ID
        function VisualizarResultados(string memory _idPersona) public view returns (string memory _resultadoPrueba, string memory _codigoIPFS) {
        bytes32 hash_idPersona = keccak256(abi.encodePacked(_idPersona));
        // Convertir el resultado en texto (Positivo/Negativo)
        string memory resultadoPrueba;
        if (resultadosGripe[hash_idPersona].diagnostico == true) {
            resultadoPrueba = "Positivo";
        } else {
            resultadoPrueba = "Negativo";
        }
        // Retornar resultado y código IPFS
        _resultadoPrueba = resultadoPrueba;
        _codigoIPFS = resultadosGripe[hash_idPersona].CodigoIPFS;
    }
}
